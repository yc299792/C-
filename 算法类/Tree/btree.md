### B-树的思考
为什么要有B-树？因为数据库这样的持久化存储会有很大的索引，所以他们需要查询操作只能把索引放在磁盘上保存，所以为了提高查找的效率又要保证插入删除的效率，所以采用了树结构，但是普通红黑树或者AVL树在这种情况下就不行了，因为这种大量数据的情况下，二叉树就会变的十分的高，那么在查找的时候就会进行很多次寻址，在磁盘上进行寻址操作就非常慢了，所以我们就想到应该怎么去减少寻址的次数，那就是要把树变矮，于是B树就能用上了。



**B-树的特点**：一棵m阶B树 可以是空树，也可以是满足下列特点的m叉树

1. 树中每个结点至多有m棵子树（即至多含有m-1个关键字）
2. 若根结点不是终端结点，则至少有2棵子树
3. 除根结点外的所有非叶结点至少有（m/2）（向上取整）棵子树，即至少含有（m/2）（向上取整）个关键字
4. 同一个结点的关键字按从小到大排序
5. 所有的叶结点都出现在同一层次上，并且不带关键字信息

**B树的高度**：若n>=1对一颗包含n个key的B树，h为高度，阶数或者叫度为m

h >= logm  (n+1);

n+1>=2(m/2)^(h-1)



**B树的查找包含两个基本的操作**
1.在B树中找结点（在磁盘）这个就是说在磁盘上寻址很慢，所以找节点应该尽量少
2.在结点内找关键字（在内存）找到节点再去内存中找关键字就快了

所以B树存储在磁盘上都是一片一片存储的每一片就是一个节点，所以节点是很大的。

**插入操作：**

1.在二叉查找树中，仅需查找到需要插入的终端结点的位置，然后直接插入即可
2.但是，在B树中找到插入的位置后，并不能简单地将其添加到终端结点中，
因为此时可能会导致整棵树不再满足B树定义中的要求（比如m叉B树每个结点不能查过m个结点）
3.将关键字key插入到B树的过程如下：
a.定位//首先找到该关键字的最低层中的某个非叶结点（注意 B树中的关键字插入一定插入在最低层的某个非叶结点内）
b.插入//若插入后的结点关键字个数小于m，可以直接插入；若插入后结点的关键字个数大于m-1时，必须对结点进行分裂

**分裂操作：**

取一个新结点，在插入key后的原结点，从中间位置将其中的关键字分为两部分，左部分包含的关键字放在原结点中，
右部分包含的关键字放到新结点中，中间位置（m/2）向上取整  的结点插入原结点的父结点。
若此时导致父结点的关键字个数也超过了上限，则继续进行这种操作，直至这个过程传到根结点为止，
进而导致B树高度增加1



**删除操作：**

1.当所删除的关键字k在终端结点（最低层非叶结点）中时，
a.若被删除关键字所在结点的关键字个数大于(m/2)-1  m/2向上取整 直接删除
b.兄弟够借则借
c.兄弟不够借则合并	

2.当所删除的关键字k不在终端结点（最低层非叶结点）中时
a.若小于k的子树中关键字个数大于(m/2)-1  m/2向上取整，则用k的前驱来代替k，再删除k
b.若大于k的子树中关键字个数大于(m/2)-1  m/2向上取整，则用k的后继来代替k，再删除k
c.若前后两个子树的关键字均为(m/2)-1  m/2向上取整，则直接将两个子结点合并，再删除k



**B+树的特点：**

一棵m阶的B+树需满足下列条件：
1.每个分支结点最多有m棵子树（子结点）
2.非叶根结点至少有两棵子树，其他每个分支结点至少有(m/2)  m/2向上取整 棵子树
3.结点的子树个数与关键字个数相等
4.所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排序，
并且相邻叶结点按大小顺序相互链接起来
5.所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）
中关键字的最大值及指向其子结点的指针

