### B-树的思考
为什么要有B-树？因为数据库这样的持久化存储会有很大的索引，所以他们需要查询操作只能把索引放在磁盘上保存，所以为了提高查找的效率又要保证插入删除的效率，所以采用了树结构，但是普通红黑树或者AVL树在这种情况下就不行了，因为这种大量数据的情况下，二叉树就会变的十分的高，那么在查找的时候就会进行很多次寻址，在磁盘上进行寻址操作就非常慢了，所以我们就想到应该怎么去减少寻址的次数，那就是要把树变矮，于是B树就能用上了。



**B-树的特点**：一棵m阶B树 可以是空树，也可以是满足下列特点的m叉树

1. 树中每个结点至多有m棵子树（即至多含有m-1个关键字）
2. 若根结点不是终端结点，则至少有2棵子树
3. 除根结点外的所有非叶结点至少有（m/2）（向上取整）棵子树，即至少含有（m/2）（向上取整）个关键字
4. 同一个结点的关键字按从小到大排序
5. 所有的叶结点都出现在同一层次上，并且不带关键字信息

**B树的高度**：若n>=1对一颗包含n个key的B树，h为高度，阶数或者叫度为m

h >= logm  (n+1);

n+1>=2(m/2)^(h-1)



**B树的查找包含两个基本的操作**
1.在B树中找结点（在磁盘）这个就是说在磁盘上寻址很慢，所以找节点应该尽量少
2.在结点内找关键字（在内存）找到节点再去内存中找关键字就快了

所以B树存储在磁盘上都是一片一片存储的每一片就是一个节点，所以节点是很大的。

**插入操作：**

1.在二叉查找树中，仅需查找到需要插入的终端结点的位置，然后直接插入即可
2.但是，在B树中找到插入的位置后，并不能简单地将其添加到终端结点中，
因为此时可能会导致整棵树不再满足B树定义中的要求（比如m叉B树每个结点不能查过m个结点）
3.将关键字key插入到B树的过程如下：
a.定位//首先找到该关键字的最低层中的某个非叶结点（注意 B树中的关键字插入一定插入在最低层的某个非叶结点内）
b.插入//若插入后的结点关键字个数小于m，可以直接插入；若插入后结点的关键字个数大于m-1时，必须对结点进行分裂

**分裂操作：**

取一个新结点，在插入key后的原结点，从中间位置将其中的关键字分为两部分，左部分包含的关键字放在原结点中，
右部分包含的关键字放到新结点中，中间位置（m/2）向上取整  的结点插入原结点的父结点。
若此时导致父结点的关键字个数也超过了上限，则继续进行这种操作，直至这个过程传到根结点为止，
进而导致B树高度增加1



**删除操作：**

1.当所删除的关键字k在终端结点（最低层非叶结点）中时，
a.若被删除关键字所在结点的关键字个数大于(m/2)-1  m/2向上取整 直接删除
b.兄弟够借则借
c.兄弟不够借则合并	

2.当所删除的关键字k不在终端结点（最低层非叶结点）中时
a.若小于k的子树中关键字个数大于(m/2)-1  m/2向上取整，则用k的前驱来代替k，再删除k
b.若大于k的子树中关键字个数大于(m/2)-1  m/2向上取整，则用k的后继来代替k，再删除k
c.若前后两个子树的关键字均为(m/2)-1  m/2向上取整，则直接将两个子结点合并，再删除k



**B+树的特点：**

一棵m阶的B+树需满足下列条件：
1.每个分支结点最多有m棵子树（子结点）
2.非叶根结点至少有两棵子树，其他每个分支结点至少有(m/2)  m/2向上取整 棵子树
3.结点的子树个数与关键字个数相等
4.所有叶结点包含全部关键字及指向相应记录的指针，叶结点中将关键字按大小顺序排序，
并且相邻叶结点按大小顺序相互链接起来
5.所有分支结点（可视为索引的索引）中仅包含它的各个子结点（即下一级的索引块）
中关键字的最大值及指向其子结点的指针

**B树和B+树的区别**

- B树的每一个节点不仅存储了key还存储了data，但是B+树的内节点是不存储data的只有叶子节点存储data，这样就使得B+树比B树的磁盘读写代价更低，因为内部节点比较小。
- B+树的查询更加的稳定，因为非叶子节点不存储数据，仅仅作为叶子节点的索引，所有关键字的查询都会走一条长度一样的路径，所以查询效率很稳定。

Mysql中的两种引擎，MyISAM和InnoDb,

MyISAM采用的是在B+树中存储数据的地址，索引是索引数据是数据，所以也叫作非聚焦索引，而InnoDb是直接把数据存储在叶子节点中的索引和数据存放在一个文件中也叫做聚焦索引。知道了数据结构以后再去看数据库的索引一点也不费解，就很顺其自然了。既然到这里了再补充一下两种引擎的其他区别：

1、MyISAM是非事务安全的，而InnoDB是事务安全的

2、MyISAM锁的粒度是表级的，而InnoDB支持行级锁

3、MyISAM支持全文类型索引，而InnoDB不支持全文索引

4、MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM

5、MyISAM表保存成文件形式，跨平台使用更加方便

6、MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量select操作可选择

7、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，可选择。


** 聚集索引和非聚集索引 **
其实非聚集索引是这样的：它的B+树的叶子节点中存储的是某一个列对应的主键，在进行查找的时候，先进行这个主键的查找，然后再根据这个主键去聚集索引中查找这个就是**回表**。
**数据即索引，索引即数据**
聚集索引的查询就是根据主键去B+树里查询，而非聚集索引是这样的：叶子节点存储的是value-key，对就是这样的键值对，什么意思呢就是每一个值对应的是主键了，然后先根据这个值去查找到主键，然后再拿到这个主键去聚集索引中查找实际的数据记录。

**总结**
树这一块东西学了一些了，总结一下
- 数据结构和算法对于程序员来说真的是内功，为什么这么说呢，当数据结构和算法学习掌握到一定程度以后，会发现再去学习那些高大上的东西会很轻松，因为原理性的东西都在这了。
- 学习知识要反复思考，反复总结，想到什么要学会记录，不是为了复习，也不是为了别的，只是写的多了理解就更加深刻了。这让我想到了一件事，高中的时候我的理科成绩非常好，当时总觉得是自己理科思维很强，其实有这方面的原因，还有一个原因就是，我们班同学经常问我问题，我会很乐意分享，现在想想每一次分享都是对自己的一个提高。一个知识点，自己理解了，如果再能讲给别人听，别人也懂了，那么证明你是真懂了。
- 学习是一个循序渐进的过程，从基础开始一点一点积累上去，越往后面越好学，否则只会什么也学不好，学着学着可能一回头就发现自己已经走了这么远了。
