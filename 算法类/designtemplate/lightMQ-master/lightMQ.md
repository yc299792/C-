### lightMQ



这是一个分布式消息队列的设计，采用发布订阅的设计思想。分为发布者，中间服务器，以及订阅者，

采用分布式的结构，各组件之间采用网络通信，基于特定的协议进行通信。

### 客户端

以订阅者的客户端SubscriberClient为例：

```C++
	    std::shared_ptr<Subscriber> subscriber_;////主要用来维护订阅的主题，内部管理一个连接对象
        std::shared_ptr<socketx::Connection> stdinConn;//标准输入的连接的对象，每一个连接对象关联一个文件描述符和事件的监听对象
        socketx::EventLoop *loop_;//用来监听事件的对象
        std::shared_ptr<socketx::Client> client_;//客户端对象，所有网路操作都由这个对象完成
        std::string hostname_;//主机ip端口号
        std::string port_;
```

其中维护了这么几个对象，每一个对象都有其专门的作用，负责不同的任务

说一下流程：

每建立一个连接的过程就是获取文件描述符的过程，操作系统会通过文件描述符管理读写事件，所以建立连接就是先通过client_的socket对象调用connect函数连接主机然后会返回一个文件描述符，然后客户端通过这个socketfd创建一个connection对象，这个对象在fd出现读写事件的时候会调用相应的函数，这些函数都是回调函数，用户只要再去指定相应的读写函数就可以了，并把socketfd和conn这个对应关系保存在map中，在建立连接对象的时候，需要让conn对象被一个loop对象监听，然后后续client就通过loop对象监听连接中的读写事件，并回调各个事件的处理函数。

## 服务端：

基本和客户端一样，唯一不同的就是，服务端创建新连接对象的时机是不一样的，当有一个新的客户端连接的时候，会调用服务端的newconnection函数创建一个新的con对象用来通信，剩下的都是事件驱动的，有事件发生就通过回调函数操作。

### 回调函数的思想：

其实就是预留接口的手段，比如这里，由于需要封装，当有一个事件发生的时候，这个事件对象就会调用自己的handleEvent方法，那么这时候就面临一个问题，事件是提供给别的模块使用的，事件也不知道这个事件应该怎么处理，那么简单，通过一个函数指针，或者接口的方式调用一个处理的接口，然后提供一个设置这个处理方式的方法就能完成回调了。然后后续其他模块在使用事件的时候，只要为事件对象提供一个方法，通过调用事件对象的setfun即可，这样就很灵活的实现了回调。